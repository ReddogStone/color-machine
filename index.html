<html>
<head>
<script src="utils.js" type="text/javascript"></script>
<script src="rdp.js" type="text/javascript"></script>
<script src="block.js" type="text/javascript"></script>
<script src="ball.js" type="text/javascript"></script>
<script src="state.js" type="text/javascript"></script>
<script src="color.js" type="text/javascript"></script>
<script src="v2.js" type="text/javascript"></script>
<script src="time.js" type="text/javascript"></script>
<script src="state-machine.js" type="text/javascript"></script>
<script src="behaviors.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
	function extractMouseCoords(canvas, event) {
		// get canvas position
		var obj = canvas;
		var top = 0;
		var left = 0;
		while (obj && obj.tagName != 'BODY') {
			top += obj.offsetTop;
			left += obj.offsetLeft;
			obj = obj.offsetParent;
		}

		// return relative mouse position
		var mouseX = event.clientX - left + window.pageXOffset;
		var mouseY = event.clientY - top + window.pageYOffset;
		return {
			x: mouseX,
			y: mouseY
		};
	}

	function registerMouseEvent(domObj, name, fire) {
		domObj.addEventListener(name, function(event) {
			fire(extractMouseCoords(domObj, event));
		}, false);
	}

	function pointInRect(point, rect) {
		var dx = point.x - rect.x;
		var dy = point.y - rect.y;
		return (dx >= 0) && (dx < rect.sx) && (dy >= 0) && (dy < rect.sy);
	}

	var g_stateMachine = CM.StateMachine.construct();
	var g_startButton = {
		pos: CM.V2.construct(512, 700),
		size: CM.V2.construct(200, 100),
		text: 'Start',
		colors: {
			up: CM.Color.construct(1, 1, 1, 1),
			down: CM.Color.construct(0.3, 0.3, 0.3, 1),
			hovered: CM.Color.construct(0.8, 0.8, 0.8, 1),
		},
		down: false,
		hovered: false,
		rect: function() {
			var pos = this.pos;
			var size = this.size;
			return {
				x: pos.x - 0.5 * size.x,
				y: pos.y - 0.5 * size.y,
				sx: size.x,
				sy: size.y
			};
		},
		pointInside: function(point) {
			return pointInRect(point, this.rect());
		}

	};

	function clear(context) {
		context.fillStyle = "white";
		context.fillRect(0, 0, 1e9, 1e9);
	}

	function drawBlock(context, pos, size, fillColor, strokeColor, lineWidth) {
		context.fillStyle = fillColor;
		context.strokeStyle = strokeColor;
		context.lineWidth = lineWidth;

		context.beginPath();
		context.rect(pos.x - size.x * 0.5 , pos.y - size.y * 0.5, size.x, size.y);
		context.fill();
		context.stroke();
	}

	function drawBall(context, pos, radius, fillColor, strokeColor, lineWidth) {
		context.fillStyle = fillColor;
		context.strokeStyle = strokeColor;
		context.lineWidth = lineWidth;

		context.beginPath();
		context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI, false);
		context.fill();
		context.stroke();
	}

	function drawText(context, pos, text, color) {
		context.font = "bold 1.2em sans-serif";
		context.fillStyle = color;
		context.textAlign = 'center';
		context.textBaseline = 'middle';
		context.fillText(text, pos.x, pos.y);
	}

	var TRANS_PERCENTAGE = 0.2;
	var TRANS_MARGIN = 10;

	function drawTransition(context, id, shift, pos, size) {
		var color = CM.Color.construct(CM.COLORS[id]);
		drawBlock(context, pos, size, color.toCSS(), color.scale(0.2).toCSS(), 3);
		drawText(context, pos, shift, 'white');
	}

	function drawTransitions(context, block) {
		var body = block.body;
		var sx = body.size.x;
		var transitions = block.state.transitions;
		var ids = Object.keys(transitions);
		var transCount = ids.length;
		for (var i = 0; i < ids.length; i++) {
			var id = ids[i];
			var shift = transitions[id];
			drawTransition(context, id, shift,
				CM.V2.construct(
					body.pos.x + ((i + 0.5) * TRANS_PERCENTAGE - 0.5) * sx, 
					body.pos.y),
				CM.V2.construct(sx * TRANS_PERCENTAGE, body.size.y));
		}
	}

	function drawBlockBody(context, block) {
		var body = block.body;
		var transitionCount = Object.keys(block.state.transitions).length;
		var color = CM.Color.construct(CM.COLORS[block.state.id]);
		var sx = body.size.x;
		var transSize = sx * transitionCount * TRANS_PERCENTAGE + TRANS_MARGIN;
		var newSize = sx - transSize - TRANS_MARGIN;
		drawBlock(context,
			CM.V2.construct(body.pos.x + 0.5 * transSize, body.pos.y),
			CM.V2.construct(newSize, body.size.y),
			color.toCSS(),
			color.scale(0.2).toCSS(),
			3);
	}

	function drawButton(context, button) {
		var state = 'up';
		if (button.hovered) {
			state = button.down ? 'down' : 'hovered';
		}
		var color = button.colors[state];
		drawBlock(context, button.pos, button.size, color.toCSS(), 'black', 3);
		drawText(context, button.pos, button.text, 'black');
	}

	function frame(context) {
		var t = performance.now();

		clear(context);
		var balls = g_stateMachine.balls;
		for (var i = 0; i < balls.length; i++) {
			var ball = balls[i];
			var body = ball.body;
			var color = CM.Color.construct(CM.COLORS[ball.id]);
			drawBall(context, 
				body.pos, 
				body.radius, 
				color.toCSS(),
				color.scale(0.2).toCSS(),
				3);
		}
		var freeBlocks = g_stateMachine.freeBlocks;
		for (var i = 0; i < freeBlocks.length; i++) {
			var block = freeBlocks[i];
			var body = block.body;
			var color = CM.Color.construct(CM.COLORS[block.state.id]);
			drawBlock(context, 
				body.pos,
				body.size, 
				color.toCSS(),
				color.scale(0.2).toCSS(),
				3);
		}
		var boundBlocks = g_stateMachine.boundBlocks;
		for (var i = 0; i < boundBlocks.length; i++) {
			var block = boundBlocks[i];
			drawBlockBody(context, block);
			drawTransitions(context, block);
		}

		drawText(context, CM.V2.construct(252, 52), 
			'Place the balls such, that after running', 'lightgray');
		drawText(context, CM.V2.construct(250, 50), 
			'Place the balls such, that after running', 'blue');
		drawText(context, CM.V2.construct(252, 77), 
			'through the machine no two neighboring balls', 'lightgray');
		drawText(context, CM.V2.construct(250, 75), 
			'through the machine no two neighboring balls', 'blue');
		drawText(context, CM.V2.construct(252, 102), 
			'are of the same color', 'lightgray');
		drawText(context, CM.V2.construct(250, 100), 
			'are of the same color', 'blue');

		drawButton(context, g_startButton);
	}

	function buttonState(target) {
		return function(value) {
			target(value);
		};
	}

	function offset(stateSignal, mousePosSignal, object) {
		var result = RDP.signal();
		stateSignal.onValue(function(value) {
			if (value == 'down') {
				var mousePos = mousePosSignal.get();
				if (object.pointInside(mousePos)) {
					var objPos = object.pos;
					return result.set({
						x: objPos.x - mousePos.x,
						y: objPos.y - mousePos.y,
					});
				}
			}

			result.set();
		});
		return result;
	}

	function drag(mousePosSignal, offsetSignal) {
		var result = RDP.signal();
		mousePosSignal.onValue(function(value) {
			var offset = offsetSignal.get();
			if (offset) {
				result.set({
					x: value.x + offset.x,
					y: value.y + offset.y
				});
			}
		});
		offsetSignal.onValue(function(value) {
			if (!value) {
				result.set();
			}
		});
		return result;
	}

	var g_currentBalls = [];
	var g_ballTargets = [];

	function squareDist(from, to) {
		var dx = to.x - from.x;
		var dy = to.y - from.y;
		return dx * dx + dy * dy;
	}

	function prioritize(first, second) {
		function handleValue() {
			res.set(first.get() || second.get());
		};

		var res = RDP.signal(first.get() || second.get());
		first.onValue(handleValue);
		second.onValue(handleValue);
		return res;
	}

	function buffer(init, signal) {
		var res = RDP.signal(init);
		signal.onValue(function(value) {
			if (value !== undefined) {
				res.set(value);
			}
		});
		return res;
	}

	function follow(init, dragSignal, targetSignal) {
		return CM.Behaviors.followTargetV2(init,
			function() { return targetSignal.get(); },
			function() { return dragSignal.get() ? 0.01 : 0.1; });
	}

	function createDragHandler(index, signal) {
		return function(value) {
			if (value !== undefined) {
				var current = signal.get().slice();
				for (var i = 0; i < current.length; i++) {
					var targetPos = g_stateMachine.ballPosition(i);
					if (squareDist(value, targetPos) < 25 * 25) {
						var currentIndex = current.indexOf(index);
						if (i !== currentIndex) {
							current.splice(currentIndex, 1);
							current.splice(i, 0, index);
						}
						signal.set(current);
						break;
					}
				}
			}
		};
	}

	function ballIndexes(dragSignals, initial) {
		var res = RDP.signal(initial);
		for (var i = 0; i < dragSignals.length; i++) {
			dragSignals[i].onValue(createDragHandler(i, res));
		}
		return res;
	}

	function returnPos(indexesSignal, myIndex) {
		var res = RDP.signal(g_stateMachine.ballPosition(myIndex));
		indexesSignal.onValue(function(value) {
			var myPosIndex = value.indexOf(myIndex);
			if (myPosIndex >= 0) {
				res.set(g_stateMachine.ballPosition(myPosIndex));
			} else {
				res.set();
			}
		});
		return res;
	}

	function createRemoveIndex(myIndex, indexesSignal, signal) {
		return function(value) {
			var indexes = indexesSignal.get().slice();
			if (value !== undefined) {
				var myPosIndex = indexes.indexOf(myIndex);
				var returnPos = g_stateMachine.ballPosition(myPosIndex);
				if (squareDist(returnPos, value) >= 25 * 25) {
					indexes.splice(myPosIndex, 1);
				}
			}
			signal.set(indexes);
		};
	}

	function shownIndexes(indexesSignal, dragSignals) {
		var res = RDP.signal(indexesSignal);
		for (var i = 0; i < dragSignals.length; i++) {
			dragSignals[i].onValue(createRemoveIndex(i, indexesSignal, res));
		}
		return res;
	}

	function bindBallPositions(balls, mousePosSignal, mouseStateSignal) {
		var originalBalls = balls.slice();
		var dragSignals = balls.map(function(ball) {
			var offsetSignal = offset(mouseStateSignal, mousePosSignal, ball.body);
			return drag(mousePosSignal, offsetSignal);
		});

		var indexes = balls.map(function(ball, index) { return index; });
		var indexesSignal = ballIndexes(dragSignals, indexes);
		var shownIndexesSignal = shownIndexes(indexesSignal, dragSignals);

		var reorder = function(value) {
			if (value === undefined) {
				var indexes = indexesSignal.get();
				var newBalls = indexes.map(function(index) { return originalBalls[index]; });
				g_stateMachine.reorderBalls(newBalls);
			}
		};

		for (var i = 0; i < dragSignals.length; i++) {
			var ball = balls[i];
			var body = ball.body;
			var dragSignal = dragSignals[i];
			dragSignal.onValue(reorder);
			var currentPosSignal = returnPos(shownIndexesSignal, i);
			var returnPosSignal = returnPos(indexesSignal, i);
			var targetSignal = prioritize(prioritize(dragSignal, currentPosSignal), returnPosSignal);
			Object.defineProperty(ball.body, 'pos', {
				configurable: true,
				get: follow(body.pos, dragSignal, targetSignal)
			});
		}
	}

	window.onload = function() {
		var canvas = document.getElementById("myCanvas");
		var context = canvas.getContext('2d');

		g_stateMachine.setBalls([0, 0, 0, 1, 1, 1, 2, 2]);
		g_stateMachine.setFreeBlocks([
			CM.State.construct(0, {'0': 0, '1': 1, '2': -1}),
			CM.State.construct(1, {'0': 0, '1': 0, '2': 1}),
			CM.State.construct(2, {'0': 1, '1': 0, '2': 0}),
		]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);

		registerMouseEvent(canvas, 'mousedown', function(e) {
			if (g_startButton.pointInside(e)) {
				g_startButton.down = true;
			}
		});
		registerMouseEvent(document, 'mouseup', function(e) {
			if (g_startButton.down && g_startButton.hovered) {
				if (g_startButton.text == 'Start') {
					g_stateMachine.start();
					g_startButton.text = 'Reset';
				} else {
					g_stateMachine.reset();
					bindBallPositions(g_stateMachine.balls, mousePos, buttonState);
					g_startButton.text = 'Start';
				}
			}
			g_startButton.down = false;
		});
		registerMouseEvent(canvas, 'mousemove', function(e) {
			g_startButton.hovered = g_startButton.pointInside(e);
		});

		var mousePos = RDP.signal({x: 0, y: 0});
		var buttonState = RDP.signal('up');

		bindBallPositions(g_stateMachine.balls, mousePos, buttonState);

		registerMouseEvent(canvas, 'mousedown', function(e) {
			buttonState.set('down');
		});
		registerMouseEvent(canvas, 'mouseup', function(e) {
			buttonState.set('up');
		});
		registerMouseEvent(canvas, 'mousemove', mousePos.set);

		(function animate() {
			frame(context);
			requestAnimationFrame(animate);
		})();
	};

</script>
<body>
	<div style="border-style: solid; border-width: thick; width: 1024px; height: 768px">
		<canvas id="myCanvas" width="1024" height="768"></canvas>
	</div>
</body>
</html>