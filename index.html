<html>
<head>
<script src="utils.js" type="text/javascript"></script>
<script src="rdp.js" type="text/javascript"></script>
<script src="block.js" type="text/javascript"></script>
<script src="ball.js" type="text/javascript"></script>
<script src="state.js" type="text/javascript"></script>
<script src="color.js" type="text/javascript"></script>
<script src="v2.js" type="text/javascript"></script>
<script src="time.js" type="text/javascript"></script>
<script src="state-machine.js" type="text/javascript"></script>
<script src="behaviors.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
	function extractMouseCoords(canvas, event) {
		// get canvas position
		var obj = canvas;
		var top = 0;
		var left = 0;
		while (obj && obj.tagName != 'BODY') {
			top += obj.offsetTop;
			left += obj.offsetLeft;
			obj = obj.offsetParent;
		}

		// return relative mouse position
		var mouseX = event.clientX - left + window.pageXOffset;
		var mouseY = event.clientY - top + window.pageYOffset;
		return {
			x: mouseX,
			y: mouseY
		};
	}

	function registerMouseEvent(domObj, name, fire) {
		domObj.addEventListener(name, function(event) {
			fire(extractMouseCoords(domObj, event));
		}, false);
	}

	function pointInRect(point, rect) {
		var dx = point.x - rect.x;
		var dy = point.y - rect.y;
		return (dx >= 0) && (dx < rect.sx) && (dy >= 0) && (dy < rect.sy);
	}

	var g_stateMachine = CM.StateMachine.construct();
	var g_startButton = {
		pos: CM.V2.construct(512, 700),
		size: CM.V2.construct(200, 100),
		text: 'Start',
		colors: {
			up: CM.Color.construct(1, 1, 1, 1),
			down: CM.Color.construct(0.3, 0.3, 0.3, 1),
			hovered: CM.Color.construct(0.8, 0.8, 0.8, 1),
		},
		down: false,
		hovered: false,
		rect: function() {
			var pos = this.pos;
			var size = this.size;
			return {
				x: pos.x - 0.5 * size.x,
				y: pos.y - 0.5 * size.y,
				sx: size.x,
				sy: size.y
			};
		},
		pointInside: function(point) {
			return pointInRect(point, this.rect());
		}

	};

	function clear(context) {
		context.fillStyle = "white";
		context.fillRect(0, 0, 1e9, 1e9);
	}

	function drawBlock(context, pos, size, fillColor, strokeColor, lineWidth) {
		context.fillStyle = fillColor;
		context.strokeStyle = strokeColor;
		context.lineWidth = lineWidth;

		context.beginPath();
		context.rect(pos.x - size.x * 0.5 , pos.y - size.y * 0.5, size.x, size.y);
		context.fill();
		context.stroke();
	}

	function drawBall(context, pos, radius, fillColor, strokeColor, lineWidth) {
		context.fillStyle = fillColor;
		context.strokeStyle = strokeColor;
		context.lineWidth = lineWidth;

		context.beginPath();
		context.arc(pos.x, pos.y, radius, 0, 2 * Math.PI, false);
		context.fill();
		context.stroke();
	}

	function drawText(context, pos, text, color) {
		context.font = "bold 1em sans-serif";
		context.fillStyle = color;
		context.textAlign = 'center';
		context.textBaseline = 'middle';
		context.fillText(text, pos.x, pos.y);
	}

	var TRANS_PERCENTAGE = 0.2;
	var TRANS_MARGIN = 10;

	function drawTransition(context, id, shift, pos, size) {
		var color = CM.Color.construct(CM.COLORS[id]);
		drawBlock(context, pos, size, color.toCSS(), color.scale(0.2).toCSS(), 3);
		drawText(context, pos, shift, 'white');
	}

	function drawTransitions(context, block) {
		var body = block.body;
		var sx = body.size.x;
		var transitions = block.state.transitions;
		var ids = Object.keys(transitions);
		var transCount = ids.length;
		for (var i = 0; i < ids.length; i++) {
			var id = ids[i];
			var shift = transitions[id];
			drawTransition(context, id, shift,
				CM.V2.construct(
					body.pos.x + ((i + 0.5) * TRANS_PERCENTAGE - 0.5) * sx, 
					body.pos.y),
				CM.V2.construct(sx * TRANS_PERCENTAGE, body.size.y));
		}
	}

	function drawBlockBody(context, block) {
		var body = block.body;
		var transitionCount = Object.keys(block.state.transitions).length;
		var color = CM.Color.construct(CM.COLORS[block.state.id]);
		var sx = body.size.x;
		var transSize = sx * transitionCount * TRANS_PERCENTAGE + TRANS_MARGIN;
		var newSize = sx - transSize - TRANS_MARGIN;
		drawBlock(context,
			CM.V2.construct(body.pos.x + 0.5 * transSize, body.pos.y),
			CM.V2.construct(newSize, body.size.y),
			color.toCSS(),
			color.scale(0.2).toCSS(),
			3);
	}

	function drawButton(context, button) {
		var state = 'up';
		if (button.hovered) {
			state = button.down ? 'down' : 'hovered';
		}
		var color = button.colors[state];
		drawBlock(context, button.pos, button.size, color.toCSS(), 'black', 3);
		drawText(context, button.pos, button.text, 'black');
	}

	function frame(context) {
		var t = performance.now();

		clear(context);
		var balls = g_stateMachine.balls;
		for (var i = 0; i < balls.length; i++) {
			var ball = balls[i];
			var body = ball.body;
			var color = CM.Color.construct(CM.COLORS[ball.id]);
			drawBall(context, 
				body.pos, 
				body.radius, 
				color.toCSS(),
				color.scale(0.2).toCSS(),
				3);
		}
		var freeBlocks = g_stateMachine.freeBlocks;
		for (var i = 0; i < freeBlocks.length; i++) {
			var block = freeBlocks[i];
			var body = block.body;
			var color = CM.Color.construct(CM.COLORS[block.state.id]);
			drawBlock(context, 
				body.pos,
				body.size, 
				color.toCSS(),
				color.scale(0.2).toCSS(),
				3);
		}
		var boundBlocks = g_stateMachine.boundBlocks;
		for (var i = 0; i < boundBlocks.length; i++) {
			var block = boundBlocks[i];
			drawBlockBody(context, block);
			drawTransitions(context, block);
		}

		drawButton(context, g_startButton);
	}

	function buttonState(target) {
		return function(value) {
			target(value);
		};
	}

	function offset(stateSignal, mousePosSignal, object) {
		var result = RDP.signal();
		stateSignal.onValue(function(value) {
			if (value == 'down') {
				var mousePos = mousePosSignal.get();
				if (object.pointInside(mousePos)) {
					var objPos = object.pos;
					return result.set({
						x: objPos.x - mousePos.x,
						y: objPos.y - mousePos.y,
					});
				}
			}

			if (result.get()) {
				result.set();
			}
		});
		return result;
	}

	function drag(mousePosSignal, offsetSignal) {
		var result = RDP.signal();
		mousePosSignal.onValue(function(value) {
			var offset = offsetSignal.get();
			if (offset) {
				result.set({
					x: value.x + offset.x,
					y: value.y + offset.y
				});
			}
		});
		return result;
	}

	var g_currentBalls = [];
	var g_ballTargets = [];

	function squareDist(from, to) {
		var dx = to.x - from.x;
		var dy = to.y - from.y;
		return dx * dx + dy * dy;
	}

	function makeDrag(ball, mousePosSignal, mouseStateSignal) {
		var object = ball.body;
		var target = null;
		var halfTime = 0.1;
		var currentIndex = g_currentBalls.indexOf(ball);
		Object.defineProperty(object, 'pos', {
			configurable: true,
			get: CM.Behaviors.followTargetV2(object.pos, 
				function() { return target || g_ballTargets[g_currentBalls.indexOf(ball)]; }, 
				function() { return halfTime; })
		});
		var offsetSignal = offset(mouseStateSignal, mousePosSignal, object);
		offsetSignal.onValue(function(offsetValue) {
			if (offsetValue) {
				halfTime = 0.01;
			} else {
				var index = g_currentBalls.indexOf(ball);
				if (index == -1) {
					g_currentBalls.splice(currentIndex, 0, ball);
				} else if (currentIndex !== index) {
					g_stateMachine.reorderBalls(g_currentBalls);
					currentIndex = index;
				}
				target = null;
				halfTime = 0.1;
			}
		});

		drag(mousePosSignal, offsetSignal).onValue(function(value) {
			target = value;
			var myIndex = g_currentBalls.indexOf(ball);
			if (myIndex >= 0) {
				var bindTarget = g_ballTargets[myIndex];
				if (squareDist(bindTarget, value) > 50 * 50) {
					g_currentBalls.splice(myIndex, 1);
				}
			} else {
				for (var i = 0; i < g_ballTargets.length; i++) {
					var ballTarget = g_ballTargets[i];
					if (squareDist(ballTarget, value) < 50 * 50) {
						g_currentBalls.splice(i, 0, ball);
						break;
					}
				}
			}
		});
	}

	window.onload = function() {
		var canvas = document.getElementById("myCanvas");
		var context = canvas.getContext('2d');

		g_stateMachine.setBalls([0, 1, 2, 1, 0, 1, 2, 0]);
		g_stateMachine.setFreeBlocks([
			CM.State.construct(0, {'0': 0, '1': -1, '2': 1}),
			CM.State.construct(1, {'0': 0, '1': 0, '2': 1}),
			CM.State.construct(2, {'0': 1, '1': 0, '2': 0}),
		]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);
		g_stateMachine.bindBlock(g_stateMachine.freeBlocks[0]);

		registerMouseEvent(canvas, 'mousedown', function(e) {
			if (g_startButton.pointInside(e)) {
				g_startButton.down = true;
			}
		});
		registerMouseEvent(document, 'mouseup', function(e) {
			if (g_startButton.down && g_startButton.hovered) {
				if (g_startButton.text == 'Start') {
					g_stateMachine.start();
					g_startButton.text = 'Reset';
				} else {
					g_stateMachine.reset();

					for (var i = 0; i < g_stateMachine.balls.length; i++) {
						makeDrag(g_stateMachine.balls[i], mousePos, buttonState);
					}

					g_startButton.text = 'Start';
				}
			}
			g_startButton.down = false;
		});
		registerMouseEvent(canvas, 'mousemove', function(e) {
			g_startButton.hovered = g_startButton.pointInside(e);
		});

/*		var dragAll = broadcast([g_button, g_strangeBlock].map(drag));

		registerMouseEvent(canvas, 'mousedown', function(e) {
			dragAll({type: 'start', value: e});
		});
		registerMouseEvent(canvas, 'mousemove', function(e) {
			dragAll({type: 'progress', value: e});
		});
		registerMouseEvent(canvas, 'mouseup', function(e) {
			dragAll({type: 'stop', value: e});
		}); */

		var mousePos = RDP.signal({x: 0, y: 0});
		var buttonState = RDP.signal('up');

		for (var i = 0; i < g_stateMachine.balls.length; i++) {
			g_currentBalls.push(g_stateMachine.balls[i]);
			g_ballTargets.push(g_stateMachine.ballPosition(i));
		}
		for (var i = 0; i < g_stateMachine.balls.length; i++) {
			makeDrag(g_stateMachine.balls[i], mousePos, buttonState);
		}

		registerMouseEvent(canvas, 'mousedown', function(e) {
			buttonState.set('down');
		});
		registerMouseEvent(canvas, 'mouseup', function(e) {
			buttonState.set('up');
		});
		registerMouseEvent(canvas, 'mousemove', mousePos.set);

		(function animate() {
			frame(context);
			requestAnimationFrame(animate);
		})();
	};

</script>
<body>
	<div style="border-style: solid; border-width: thick; width: 1024px; height: 768px">
		<canvas id="myCanvas" width="1024" height="768"></canvas>
	</div>
</body>
</html>